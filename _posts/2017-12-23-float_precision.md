---
layout: post
comments: true
title: 浮点数计算的精度问题
date: 2017-12-23
tag: Javascript
---

0.1+0.2 = 0.3; 这是小孩子都知道的算式，我们应认为理所当然的是这样。但是计算机可不这样认为。 在编程语言中，不加任何修饰的去判断`0.1+0.2 == 0.3`, 结果都是`false`。 这个并不是编程中的bug， 而是由计算机的本质决定的。

###  精度缺失的原因

计算机的所有数据都是二进制存储，直白一句话就是`计算机的二进制实现和位数限制有些数无法有限表示`。 在计算机中，01.+0.2的真实结果是0.30000000000000004。

0.1的二进制表示： 
0.1 => 0.0001 1001 1001 1001…（无限循环）

0.2的二进制表示：
0.2 => 0.0011 0011 0011 0011…（无限循环）

所以单独靠计算机是得不到正确的四则运算结果，必须采取一定的手段解决，不然类似财务数据根本实现不了。


###  Js处理精度的一般处理

编程语言中处理计算精度问题一般的思路是，把需要计算的数字乘以10的n次幂，换算成计算机能够精确识别的整数，然后再除以10的n次幂。

```javascript
// a + b 浮点数的精度计算
function addNum(a,b){
    var r1,r2,m;
    try {
       	r1 = a.toString().split('.')[1].length; 
    } catch (e){
        r1 = 0;
    }
    try {
        r2 = b.toString().split('.')[1].length;
    } catch (e) {
      	r2 = 0;
    }
    // 10 的n次幂
    m = Math.pow(10, Math.max(r1,r2));
    
    return (a*m + b*m)/m ;
}
```


###  PHP的精度处理

类似于javascript，PHP也是弱类型语言，但是PHP封装了方法处理浮点数计算的精度问题。

PHP为任意精度数学计算提供了二进制计算器（Binary Calculator）,它支持任意大小和精度的数字

* bcadd  -- 加法
* bcsub  --减法
* bccomp  --比较
* bcdiv  -- 相除
* bcmod  -- 求余数
* bcmul  --乘法
* bcpow  --次方
* bcpowmod  --先次方然后求余数
* bcscale  --给所有函数设置小数位精度
* bcsqrt  --求平方根

 

###  每日一言

* 人生中多数的不幸并非由厄运造成的，而是笨拙、倦怠和粗俗导致的  --《草叶集》 

转载请注明： [王龙的博客](http://www.wanglong.org.cn)  >>  [浮点数计算的精度问题](http://www.wanglong.org.cn/2017/12/float_precision/)